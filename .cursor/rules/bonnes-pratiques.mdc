---
description: 
globs: 
alwaysApply: true
---
# ğŸ¯ Bonnes Pratiques Techniques - Cash App

> **Objectif** : Centraliser toutes les bonnes pratiques techniques du projet pour garantir un cadre clair, cohÃ©rent et partagÃ© entre tous les membres de l'Ã©quipe.

---

## ğŸ“‹ Table des matiÃ¨res

- [ğŸ”§ Pratiques Communes](mdc:#-pratiques-communes)
- [ğŸ¨ Front-end](mdc:#-front-end)
- [âš™ï¸ Back-end](mdc:#ï¸-back-end)
- [ğŸ—ï¸ Architecture](mdc:#ï¸-architecture)
- [ğŸ§ª Tests](mdc:#-tests)
- [ğŸ“š Ressources](mdc:#-ressources)

---

## ğŸ”§ Pratiques Communes

### TypeScript Strict Mode

**RÃ¨gle** : Typage strict TypeScript partout, sans exception.

```typescript
// âœ… Bon - Typage strict
interface User {
  id: string;
  email: string;
  name: string;
}

const getUser = async (id: string): Promise<User | null> => {
  // ...
};

// âŒ Mauvais - Any ou pas de typage
const getUser = async (id: any) => {
  // ...
};
```

**Configuration** : VÃ©rifiez que `tsconfig.json` contient :
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
```

### Architecture Domain-Based

**RÃ¨gle** : Organiser le code par domaines mÃ©tier, pas par types techniques.

```
ğŸ“ Structure recommandÃ©e :
â”œâ”€â”€ domains/
â”‚   â”œâ”€â”€ user/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â””â”€â”€ composables/
â”‚   â”œâ”€â”€ payment/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â””â”€â”€ composables/
â”‚   â””â”€â”€ transaction/
â”‚       â”œâ”€â”€ components/
â”‚       â”œâ”€â”€ services/
â”‚       â”œâ”€â”€ types/
â”‚       â””â”€â”€ composables/
```

### Nommage et Conventions

- **Fichiers** : `kebab-case` (ex: `user-profile.vue`)
- **Composants** : `PascalCase` (ex: `UserProfile.vue`)
- **Variables/Fonctions** : `camelCase` (ex: `getUserProfile`)
- **Constantes** : `UPPER_SNAKE_CASE` (ex: `API_BASE_URL`)
- **Types/Interfaces** : `PascalCase` (ex: `UserProfile`)

---

## ğŸ¨ Front-end

### Composants RÃ©utilisables

**RÃ¨gle** : CrÃ©er des composants atomiques, rÃ©utilisables et testables.

```vue
<!-- âœ… Bon - Composant rÃ©utilisable avec props typÃ©es -->
<template>
  <div class="card" :class="variant">
    <slot name="header" />
    <div class="card-body">
      <slot />
    </div>
    <slot name="footer" />
  </div>
</template>

<script setup lang="ts">
interface Props {
  variant?: 'default' | 'primary' | 'secondary';
}

const props = withDefaults(defineProps<Props>(), {
  variant: 'default'
});
</script>
```

### Aucun Appel API Direct dans les Composants

**RÃ¨gle** : Les composants ne doivent jamais appeler directement les APIs. Utiliser des services centralisÃ©s.

```typescript
// âœ… Bon - Service API centralisÃ©
// services/user.service.ts
export class UserService {
  static async getUser(id: string): Promise<User> {
    const response = await $fetch(`/api/users/${id}`);
    return response;
  }
  
  static async updateUser(id: string, data: Partial<User>): Promise<User> {
    const response = await $fetch(`/api/users/${id}`, {
      method: 'PUT',
      body: data
    });
    return response;
  }
}

// âœ… Bon - Composant qui utilise le service
// components/UserProfile.vue
<script setup lang="ts">
const { data: user, pending, error } = await useLazyAsyncData(
  'user',
  () => UserService.getUser(props.userId)
);
</script>
```

### Gestion d'Ã‰tat avec Pinia

**RÃ¨gle** : Utiliser Pinia pour tous les Ã©tats globaux, pas Vuex.

```typescript
// stores/user.store.ts
export const useUserStore = defineStore('user', () => {
  const user = ref<User | null>(null);
  const isAuthenticated = computed(() => !!user.value);
  
  const setUser = (newUser: User) => {
    user.value = newUser;
  };
  
  const logout = () => {
    user.value = null;
  };
  
  return {
    user: readonly(user),
    isAuthenticated,
    setUser,
    logout
  };
});
```

### Composables pour la Logique MÃ©tier

**RÃ¨gle** : Extraire la logique mÃ©tier dans des composables rÃ©utilisables.

```typescript
// composables/useUser.ts
export const useUser = () => {
  const userStore = useUserStore();
  
  const fetchUser = async (id: string) => {
    try {
      const user = await UserService.getUser(id);
      userStore.setUser(user);
      return user;
    } catch (error) {
      console.error('Erreur lors de la rÃ©cupÃ©ration de l\'utilisateur:', error);
      throw error;
    }
  };
  
  return {
    user: userStore.user,
    isAuthenticated: userStore.isAuthenticated,
    fetchUser,
    logout: userStore.logout
  };
};
```

---

## âš™ï¸ Back-end

### Services Backend DÃ©coupÃ©s et Testables

**RÃ¨gle** : Les routes n'appellent jamais directement la BDD. Utiliser des services partagÃ©s via `/core`.

```typescript
// âœ… Bon - Service backend dÃ©coupÃ©
// core/services/user.service.ts
export class UserService {
  constructor(private prisma: PrismaClient) {}
  
  async findById(id: string): Promise<User | null> {
    return this.prisma.user.findUnique({
      where: { id },
      include: { profile: true }
    });
  }
  
  async create(data: CreateUserData): Promise<User> {
    return this.prisma.user.create({
      data,
      include: { profile: true }
    });
  }
  
  async update(id: string, data: UpdateUserData): Promise<User> {
    return this.prisma.user.update({
      where: { id },
      data,
      include: { profile: true }
    });
  }
}

// âœ… Bon - Route qui utilise le service
// server/api/users/[id].get.ts
export default defineEventHandler(async (event) => {
  const id = getRouterParam(event, 'id');
  const userService = new UserService(prisma);
  
  try {
    const user = await userService.findById(id);
    if (!user) {
      throw createError({
        statusCode: 404,
        statusMessage: 'Utilisateur non trouvÃ©'
      });
    }
    return user;
  } catch (error) {
    throw createError({
      statusCode: 500,
      statusMessage: 'Erreur serveur'
    });
  }
});
```

### Gestion d'Erreurs CentralisÃ©e

**RÃ¨gle** : Centraliser la gestion d'erreurs avec des types d'erreur spÃ©cifiques.

```typescript
// core/errors/app-error.ts
export class AppError extends Error {
  constructor(
    public statusCode: number,
    public message: string,
    public code?: string
  ) {
    super(message);
    this.name = 'AppError';
  }
}

export class ValidationError extends AppError {
  constructor(message: string) {
    super(400, message, 'VALIDATION_ERROR');
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super(404, `${resource} non trouvÃ©`, 'NOT_FOUND');
  }
}

// core/middleware/error-handler.ts
export default defineEventHandler((event) => {
  event.node.res.on('error', (error) => {
    if (error instanceof AppError) {
      throw createError({
        statusCode: error.statusCode,
        statusMessage: error.message
      });
    }
    
    // Log l'erreur pour le debugging
    console.error('Erreur non gÃ©rÃ©e:', error);
    
    throw createError({
      statusCode: 500,
      statusMessage: 'Erreur interne du serveur'
    });
  });
});
```

### Validation des DonnÃ©es

**RÃ¨gle** : Valider toutes les donnÃ©es d'entrÃ©e avec Zod ou Joi.

```typescript
// core/schemas/user.schema.ts
import { z } from 'zod';

export const createUserSchema = z.object({
  email: z.string().email('Email invalide'),
  name: z.string().min(2, 'Le nom doit contenir au moins 2 caractÃ¨res'),
  password: z.string().min(8, 'Le mot de passe doit contenir au moins 8 caractÃ¨res')
});

export const updateUserSchema = createUserSchema.partial();

// server/api/users.post.ts
export default defineEventHandler(async (event) => {
  const body = await readBody(event);
  
  try {
    const validatedData = createUserSchema.parse(body);
    const userService = new UserService(prisma);
    const user = await userService.create(validatedData);
    return user;
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw createError({
        statusCode: 400,
        statusMessage: 'DonnÃ©es invalides',
        data: error.errors
      });
    }
    throw error;
  }
});
```

---

## ğŸ—ï¸ Architecture

### Structure des Dossiers

```
ğŸ“ Structure recommandÃ©e pour un projet Nuxt 3 :
â”œâ”€â”€ app.vue
â”œâ”€â”€ nuxt.config.ts
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ package.json
â”œâ”€â”€ core/                          # Code partagÃ© entre front/back
â”‚   â”œâ”€â”€ services/                  # Services mÃ©tier
â”‚   â”œâ”€â”€ types/                     # Types TypeScript partagÃ©s
â”‚   â”œâ”€â”€ utils/                     # Utilitaires
â”‚   â”œâ”€â”€ constants/                 # Constantes
â”‚   â””â”€â”€ errors/                    # Classes d'erreur
â”œâ”€â”€ server/                        # API routes Nuxt
â”‚   â”œâ”€â”€ api/                       # Endpoints API
â”‚   â”œâ”€â”€ middleware/                # Middleware serveur
â”‚   â””â”€â”€ utils/                     # Utilitaires serveur
â”œâ”€â”€ components/                    # Composants Vue
â”‚   â”œâ”€â”€ ui/                        # Composants UI rÃ©utilisables
â”‚   â””â”€â”€ domain/                    # Composants spÃ©cifiques au domaine
â”œâ”€â”€ composables/                   # Composables Vue
â”œâ”€â”€ stores/                        # Stores Pinia
â”œâ”€â”€ pages/                         # Pages de l'application
â”œâ”€â”€ layouts/                       # Layouts
â”œâ”€â”€ public/                        # Assets statiques
â””â”€â”€ layers/                        # Modules Nuxt (si applicable)
```

### SÃ©paration des ResponsabilitÃ©s

**RÃ¨gle** : Chaque couche a une responsabilitÃ© claire et ne dÃ©pend que des couches infÃ©rieures.

```
ğŸ“Š Architecture en couches :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Pages/Components          â”‚ â† Interface utilisateur
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           Composables               â”‚ â† Logique mÃ©tier Vue
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚            Services                 â”‚ â† Appels API
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         API Routes                  â”‚ â† ContrÃ´leurs
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Core Services               â”‚ â† Logique mÃ©tier
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Base de donnÃ©es             â”‚ â† Persistance
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§ª Tests

### Tests Unitaires

**RÃ¨gle** : Tester tous les services et composables.

```typescript
// tests/unit/services/user.service.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { UserService } from '~/core/services/user.service';

describe('UserService', () => {
  let userService: UserService;
  
  beforeEach(() => {
    userService = new UserService(mockPrisma);
  });
  
  it('should find user by id', async () => {
    const mockUser = { id: '1', name: 'John' };
    mockPrisma.user.findUnique.mockResolvedValue(mockUser);
    
    const result = await userService.findById('1');
    
    expect(result).toEqual(mockUser);
    expect(mockPrisma.user.findUnique).toHaveBeenCalledWith({
      where: { id: '1' }
    });
  });
});
```

### Tests d'IntÃ©gration

**RÃ¨gle** : Tester les endpoints API.

```typescript
// tests/integration/api/users.test.ts
import { describe, it, expect } from 'vitest';
import { createEvent } from 'h3';

describe('Users API', () => {
  it('should return 404 for non-existent user', async () => {
    const event = createEvent({
      method: 'GET',
      url: '/api/users/999'
    });
    
    const response = await getUserHandler(event);
    
    expect(response.statusCode).toBe(404);
  });
});
```

---

## ğŸ“š Ressources

### Outils RecommandÃ©s

- **Tests** : Vitest + Vue Test Utils
- **Validation** : Zod
- **Base de donnÃ©es** : Prisma
- **Ã‰tat global** : Pinia
- **HTTP Client** : $fetch (Nuxt 3)

### Liens Utiles

- [Documentation Nuxt 3](mdc:https:/nuxt.com/docs)
- [Guide TypeScript Nuxt](mdc:https:/nuxt.com/docs/guide/concepts/typescript)
- [Documentation Pinia](mdc:https:/pinia.vuejs.org)
- [Documentation Prisma](mdc:https:/www.prisma.io/docs)
- [Documentation Zod](mdc:https:/zod.dev)

### Checklist de Code Review

- [ ] Typage TypeScript strict
- [ ] Pas d'appel API direct dans les composants
- [ ] Services centralisÃ©s utilisÃ©s
- [ ] Gestion d'erreurs appropriÃ©e
- [ ] Tests unitaires prÃ©sents
- [ ] Nommage cohÃ©rent
- [ ] Documentation des fonctions complexes
- [ ] Pas de code dupliquÃ©

---

> **Note** : Ce document est vivant et doit Ãªtre mis Ã  jour rÃ©guliÃ¨rement avec l'Ã©volution du projet et les retours d'expÃ©rience de l'Ã©quipe. 